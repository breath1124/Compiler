%{

open Absyn

// Vardesc 返回的是一个 元组 (g,s)
// g是类型构造函数，s是变量名
// compose1 函数 取出 类型构造子 g，用类型复合机制构造类型。

let compose1 f (g, s) = ((fun x -> g(f(x))), s)
let nl = CstI 10 //  \n 的 ASCII 码

let first   (a, _, _) = a
let second  (_, b, _) = b
let third   (_, _, c) = c

%}

%token <int> CSTINT CSTBOOL  // <int> 是词元的语义值类型
%token <string> CSTSTRING NAME
%token <float> CSTFLOAT
%token <char> CSTCHAR

%token CHAR ELSE IF INT NULL PRINT PRINTLN RETURN VOID WHILE FLOAT SWITCH CASE FOR IN RANGE STRING DO LOOP
%token PLUS MINUS TIMES DIV MOD AUTOPLUS AUTOMINUS
%token STRUCT
%token TRY CATCH THROW
%token EQ NE GT LT GE LE
%token NOT SEQOR SEQAND
%token LPAR RPAR LBRACE RBRACE LBRACK RBRACK SEMI COMMA ASSIGN AMP CONTINUE BREAK
%token EOF

%right ASSIGN             /* 最低优先级 */
%nonassoc PRINT
%left SEQOR
%left SEQAND
%left EQ NE 
%nonassoc GT LT GE LE
%left PLUS MINUS
%left TIMES DIV MOD 
%nonassoc NOT AMP AUTOPLUS AUTOMINUS
%nonassoc LBRACK          /* 最高优先级 */

%start Main            // 语法开始符号
%type <Absyn.program> Main   // 开始符号，对应抽象语法树节点类型, program

%%

Main:
    Topdecs EOF                         { Prog $1 }  // { }内是合法的F#代码
                                        // $1 是 Topdecs的语义值， Prog $1 返回抽象语法树根节点，也就是整个程序
;                                       // 规则结束符

TopDecs:
    /* empty */                         { [] }
  | Topdec Topdecs                      { $1 :: $2 }
;

TopDec: 
    VarDec SEMI                         { VarDec (fst $1, snd $1) }
  | VarDecAsg SEMI                      { VarDecAsg (first $1, second $1, third $1)}
  | StructDec SEMI                      { StructDec (fst $1, snd $1)}
  | Fundec                              { $1 }
;

StructDec:
  | STRUCT NAME LBRACE MemberList RBRACE { ($2, $4) }
;

MemberList:
  | VarDec SEMI MemberList { $1 :: $3}
;

/*                                               
变量声明  由于C 类型声明的复杂性，这里用了函数式编程的技巧来辅助类型构造
*/

VarDec:
    Type VarDesc                        { ((fst $2) $1, snd $2) }
;

VarDecAsg:
    Type VarDecAsg ASSIGN Expr         { ((fst $2) $1, snd $2, $4) }
;

/*
 变量描述
NAME  "n"   (fun t->t, "n") 返回一个元组，第一个元素，是类型构造函数，在Vardec 规则中使用
*/ 

// 变量描述
VarDesc:                         
    NAME                                { ((fun t -> t), $1)                      }
  | TIMES VarDesc                       { compose1 TypP $2                        }                                 
  | LPAR VarDesc RPAR                   { $2                                      } 
  | VarDesc LBRACK RBRACK               { compose1 (fun t -> TypA(t, None)) $1    }
  | VarDesc LBRACK CSTINT RBRACK        { compose1 (fun t -> TypA(t, Some $3)) $1 }
;

Fundec:
    VOID NAME LPAR Paramdecs RPAR Block { Fundec(None,     $2, $4, $6) }
  | Type NAME LPAR Paramdecs RPAR Block { Fundec(Some($1), $2, $4, $6) }
;

// 参数列表
Paramdecs:
    /* empty */                         { [] }
  | Paramdecs1                          { $1 }
;

Paramdecs1:
    VarDec                              { [$1]     }
  | VarDec COMMA Paramdecs1             { $1 :: $3 }
;

// 花括号中的 语句块
Block:
    LBRACE StmtOrDecSeq RBRACE          { Block $2 }
;

StmtOrDecSeq:
    /* empty */                         { [] }
  | Stmt StmtOrDecSeq                   { Stmt $1 :: $2 }
  | VarDec SEMI StmtOrDecSeq            { Dec (fst $1, snd $1) :: $3 }
  | VarDecAsg SEMI StmtOrDecSeq         { DecAsg (first $1, second $1, third $1) :: $3}
;

Stmt: 
    StmtM                               { $1 }
  | StmtU                               { $1 }
;

